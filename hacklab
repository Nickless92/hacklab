#!/bin/bash

# 
set -eEuo pipefail      # make script fail on any errors/return!=0
#set -x                 # VERY verbose, prints every step before its execution

# color variables
green='\e[32m'
light_cyan='\e[96m' 
red='\e[31m'
clearcolor='\e[0m'

# color functions
ColorGreen() {
    echo -ne $green$1$clearcolor
}
Colorlight_cyan() {
    echo -ne $light_cyan$1$clearcolor
}
ColorRed() {
    echo -ne $red$1$clearcolor
}

function pushDatabaseToServer()
{
    if [ -f localDatabase.txt.gpg ]; then
        timeStamp=$(date +%s)
        scp ./localDatabase.txt.gpg hacklab@10.215.33.91:/home/hacklab/uploadedFiles/databaseHacklab-${timeStamp}-${RANDOM}.txt.gpg 
    else
        return
    fi
}

function createDatabase()
{
    if [ -f localDatabase.txt.asc ]; then
        timeStamp=$(date +%s)
        scp /home/dominic/hacklab/localDatabase.txt.asc hacklab@10.215.33.91:/home/hacklab/uploadedFiles/databaseHacklab-${timeStamp}-${RANDOM}.txt.gpg
    else
        echo -e "Username;email;submission data;level;points\n" >> database.txt
    fi
}

function welcome_screen() {
    clear
    sleep 1s
    cat ./ressources/ascii/welcome.txt                                              # prints an Ascii graphic
    sleep 2s                                                                        # the user can see the graphic for two seconds
    clear
    enter_name
}

function enter_name() {
    echo -e "\nPlease enter the hacker-name you want to be addressed with, enter x to exit"
    read name
    if [[ $name = "x" ]]; then exit 0; else introduction; fi 
}

function introduction() {
    clear
    cat <<-____HERE
Welcome to hacklab $(ColorGreen $name)!
This is a game in which you can start learning how to
manipulate networks and defend yourself from cyber attacks.
To start, we will need to know how much knowledge you already posess.
Please choose one of the following options:

____HERE
    choose_stage
}

function choose_stage () {
    i=1
    while [ $i -ne 4 ]; do
        echo -ne "$(Colorlight_cyan  "$i"')')"                                       # numers in this form 1)--will be printed  
        awk 'NR=='$i'{ print}' ./ressources/read.txt                                 # Pupil STudent Expert will be read line by line
        i=$(($i+1))
    done
    echo -ne "$(ColorRed 'e(x)it')\n"
    echo -ne "Please choose your knowledge: "

    read -n 1 menuinput
    case $menuinput in
	1) echo -e "\nyou chose pupil.\n" ; return 3 ;;                                 # return 3 means that the function pupil_levels is going to run
	2) echo -e "\nyou chose student.\n" ; return 4 ;;                               # return 4 means that the function module_menu is going to run
	3) echo -e "\nyou chose expert.\n" ; return 7 ;;                                # return 7 means that the function expert_levels is going to run
	x) echo -e "\nyou chose exit" ; exit 0 ;;
    *) echo -e $red"\nWrong option.\n"$clear; return 2;;                            # return 2 means that the function choose_stage is going to run
    esac
}

function pupil_levels () {
    read_level pupil
    print_back_exit_options
	echo -ne "\nChoose a level: "

    read -n 1 menuinput
    case $menuinput in
        1) echo -e "\nyou chose level 1. Sorry, this is empty...";  pupil_levels ;;
        2) echo -e "\nyou chose level 2. Sorry, this is empty...";  pupil_levels ;;
        3) echo -e "\nyou chose level 3. Sorry, this is empty...";  pupil_levels ;;
        4) echo -e "\nyou chose level 4. Sorry, this is empty...";  pupil_levels ;;
        5) echo -e "\nyou chose level 5. Sorry, this is empty...";  pupil_levels ;;
        b) echo -e "\nyou chose back\n";                            choose_stage ;;            
        x) echo -e "\nyou chose exit"; exit 0 ;;
        *) echo -e $red"\nWrong option.\n"$clearcolor;              pupil_levels;;
    esac
}

function module_menu () {
    echo -ne "$(Colorlight_cyan '1)')     -  Networks (german: Netzwerke)\n"
    echo -ne "$(Colorlight_cyan '2)')     -  Network Security\n"
    print_back_exit_options
    echo -ne "Please choose a module: "

    read -n 1 menuinput
    case $menuinput in
    1) echo -e "\nyou chose Network Technologies.\n";   network_levels ;;
    2) echo -e "\nyou chose Network Security.\n";       netsec_levels ;;
    b) echo -e "\nyou chose back\n";                    choose_stage ;;
    x) echo -e "\nyou chose exit"; exit 0 ;;
    *) echo -e $red"\nWrong option.\n"$clearcolor;      module_menu ;;
    esac
}


function network_levels () {
    read_level network                                                              # call read_level function with parameter network
    #level 5
    print_back_exit_options
	echo -ne "\nChoose a level: "

    read -n 1 menuinput
    case $menuinput in
	1)  . ./levels/01-test/tmux_create_session.sh;                                  # splits tmux in different windows
        . upload $name 1;
        network_levels ;;
	2)  ./levels/level2_netzwerk_arp_poisoning/tmux_create_session.sh;
         network_levels ;;
#	2) echo -e "you chose level 2. starting..." ; sudo tmux new-session -s lvl02 -d 'lxc shell lvl02-c02'\; split-window -v -d 'lxc shell lvl02-c01' \; split-window -h -d 'lxc shell lvl02-c03' \; attach ; clear ; ../levels/level2_netzwerk_arp_poisoning/Auswertung.sh ;  network_levels ;;
	3) echo -e "\nyou chose level 3" ;              network_levels ;;
	4) echo -e "\nyou chose level 4" ;              network_levels ;;
	5) echo -e "\nyou chose level 5" ;              network_levels ;;
	b) echo -e "\nyou chose back\n";                module_menu ;;
	x) echo -e "\nyou chose exit"; exit 0 ;;
	*) echo -e $red"\nWrong option.\n"$clearcolor;  network_levels ;;
    esac
}

function netsec_levels () {
    read_level net-sec                                                              # call read_level function with parameter net-sec
    #level 5
    print_back_exit_options        
	echo -ne "Choose a level: "

    read -n 1 menuinput
    case $menuinput in
    1) echo -e "\nyou chose level 1. this is empty." ;  netsec_levels ;;
	2) echo -e "\nyou chose level 2. this is empty." ;  netsec_levels ;;
	3) echo -e "\nyou chose level 3. this is empty." ;  netsec_levels ;;
	4) echo -e "\nyou chose level 4. this is empty." ;  netsec_levels ;; 
	5) echo -e "\nyou chose level 5. this is empty." ;  netsec_levels ;;
    b) echo -e "\nyou chose back\n";                    module_menu ;;
    x) echo -e "\nyou chose exit" ; exit 0 ;;
    *) echo -e $red"\nWrong option.\n"$clearcolor;      netsec_levels ;;
    esac
}

function expert_levels() {
    read_level expert                                                                # call read_level function with parameter expert
    #level 5
    print_back_exit_options
    echo -ne "Choose a level: "

    read -n 1 menuinput
    case $menuinput in
    1) echo -e "\nyou chose level 1. this is empty." ;  expert_levels ;;
	2) echo -e "\nyou chose level 2. this is empty." ;  expert_levels ;;
	3) echo -e "\nyou chose level 3. this is empty." ;  expert_levels ;;
	4) echo -e "\nyou chose level 4. this is empty." ;  expert_levels ;; 
	5) echo -e "\nyou chose level 5. this is empty." ;  expert_levels ;;
    b) echo -e "\nyou chose back\n";                    choose_stage ;;            
    x) echo -e "\nyou chose exit" ; exit 0 ;;
    *) echo -e $red"\nWrong option.\n"$clearcolor;      expert_levels ;;
    esac    
}

function read_level()
{
	i=1
    if [ pupil = $1 ] ; then
        startline=$(( $( grep -n "<pupil>" ./ressources/level_description.txt | sed s/':.*'/''/ ) + 1 ))        # extract line where <TAG> appears
        endline=$(( $( grep -n "</pupil>" ./ressources/level_description.txt | sed s/':.*'/''/ ) - 1 ))         # extract line where <TAG> appears
        print_level                                                                                             # call print_level function to print from start to end line
   elif [ network = $1 ] ; then
        startline=$(( $( grep -n "<network>" ./ressources/level_description.txt | sed s/':.*'/''/ ) + 1 ))      # extract line where <TAG> appears
        endline=$(( $( grep -n "</network>" ./ressources/level_description.txt | sed s/':.*'/''/ ) - 1 ))       # extract line where <TAG> appears
        print_level
    elif [ net-sec = $1 ] ; then
        startline=$(( $( grep -n "<net-sec>" ./ressources/level_description.txt | sed s/':.*'/''/ ) + 1 ))       # extract line where <TAG> appears
        endline=$(( $( grep -n "</net-sec>" ./ressources/level_description.txt | sed s/':.*'/''/ ) - 1 ))        # extract line where <TAG> appears
        print_level
    fi 
}

function print_level
{
    while [ $startline -le $endline ]; do                                                                       # loop from start Tag to end Tag
        select_line=$(awk 'NR=='$startline'{print}' ./ressources/level_description.txt)                         # save the selected line from selected file in the variable 
        echo -e "$(Colorlight_cyan  $i')') $select_line"                                                        # print colored 1) and then the selected line
        i=$(($i+1))                                                                                             # increment due to i) and level i
        startline=$(($startline+1))                                                                             # increment till startline reaches endline
    done
}

function print_back_exit_options() {
	echo -ne "$(ColorRed 'b)ack')  -  Back to previous menu\n"
	echo -ne "$(ColorRed 'e(x)it')\n" 
}

# cd into hacklabdir (= path/to/hacklab)
hacklabdir=$(dirname $(readlink -f "$0"))
cd $hacklabdir

# add relevant paths to environment
PATH=$(echo $PATH:$hacklabdir:$hacklabdir/scripts:$hacklabdir/backend)

# check if required tools are available
verify_tools.sh

# main menu
welcome_screen
