#!/bin/bash

# Color  select_lineiables

green='\e[32m'
light_cyan='\e[96m' 
red='\e[31m'
clear='\e[0m'

# Color Functions

ColorGreen()
{
    echo -ne $green$1$clear
}
Colorlight_cyan()
{
    echo -ne $light_cyan$1$clear
}
ColorRed()
{
    echo -ne $red$1$clear
}

function pushDatabaseToServer()
{
    if [ -f localDatabase.txt.gpg ]; then
        timeStamp=$(date +%s)
        scp ./localDatabase.txt.gpg hacklab@10.215.33.91:/home/hacklab/uploadedFiles/databaseHacklab-${timeStamp}-${RANDOM}.txt.gpg 
    else
        return
    fi
}

function createDatabase()
{
    if [ -f database.txt ]; then
        return
    else
        echo -e "Username ; inf-Name ; submission data ; level - points\n" >> database.txt
    fi
}

function welcome_screen()
{
    clear
    sleep 1s
    cat ./ressources/ascii/welcome.txt                                              # prints an Ascii graphic
    sleep 2s                                                                        # the user can see the graphic for two seconds
    clear
}

function enter_name()
{
    echo -e "\nPlease enter the hacker-name you want to be addressed with, enter x to exit"
    read name 
    if [ "$name" == "x" ] ; then                                                    # if the user puts in x the programm is going to exit 
	    exit 0
    else
        return 2                                                                    # return 2 means that the function choose_stage is going to run
    fi 
}

function choose_stage () 
{
    i=1
    while [ $i -le 3 ]                                                              #read the 3 Levels from File
    do
        echo -ne "$(Colorlight_cyan  "$i"')')"                                      # numers in this form 1)--will be printed  
        awk 'NR=='$i'{ print}' ./ressources/read.txt                                # Pupil STudent Expert will be read line by line
        i=$(($i+1))
    done
    echo -ne "$(ColorRed 'e(x)it')\n"
    echo -ne "Please choose your knowledge: "

    read -n 1 menuinput
    case $menuinput in 
	1) echo -e "\nyou chose pupil.\n" ; return 3 ;;                                 #return 3 means that the function pupil_levels is going to run
	2) echo -e "\nyou chose student.\n" ; return 4 ;;    #return 4 means that the function module_menu is going to run
	3) echo -e "\nyou chose expert.\n" ; return 7 ;;                                #return 7 means that the function expert_levels is going to run
	x) echo -e "\nyou chose exit" ; return 0 ;; 
    *) echo -e $red"\nWrong option.\n"$clear; return 2;;                            # return 2 means that the function choose_stage is going to run
    esac
}

function pupil_levels () 
{ 
    read_level pupil                                                                #call read_level function with parameter pupil
    back_exit                                                                       #call bach_exit function 
	echo -ne "\nChoose a level: "

    read -n 1 menuinput
    case $menuinput in
    1) echo -e "\nyou chose level 1. starting..." ; return 3 ;;
	2) echo -e "\nyou chose level 2" ; return 3 ;;
	3) echo -e "\nyou chose level 3" ; return 3 ;;
	4) echo -e "\nyou chose level 4" ; return 3 ;;
	5) echo -e "\nyou chose level 5" ; return 3 ;;
    b) echo -e "\nyou chose back\n"; return 2 ;;                                    # return 2 means that the function choose_stage is going to run
    x) echo -e "\nyou chose exit" ; return 0 ;;
    *) echo -e $red"\nWrong option.\n"$clear; return 3;;                            # return 3 means that the function pupil_levels is going to run
    esac
}

function module_menu ()
{
    echo -ne "$(Colorlight_cyan '1)')     -  Networks (german: Netzwerke)\n"
    echo -ne "$(Colorlight_cyan '2)')     -  Network Security\n"
    back_exit
    echo -ne "Please choose a module: "

    read -n 1 menuinput
    case $menuinput in
    1) echo -e "\nyou chose networks.\n" ; return 5 ;;                              # return 5 means that the function networks_levels is going to run
    2) echo -e "\nyou chose Network Security.\n" ; return 6 ;;                      # return 6 means that the function netsec_levels is going to run
    b) echo -e "\nyou chose back\n"; return 2 ;;                                    # return 2 means that the function choose_stage is going to run
    x) echo -e "\nyou chose exit" ; return 0 ;;
    *) echo -e $red"\nWrong option.\n"$clear; return 4;;                            # return 4 means that the function module_menu is going to run
    esac

}


function networks_levels () 
{  
    read_level pupil                                                                # call read_level function with parameter network
    back_exit                                                                       # call back_exit function 
	echo -ne "\nChoose a level: "

    read -n 1 menuinput
    case $menuinput in
    1)  . ./levels/01-test/tmux_create_session.sh;                                  # splits tmux in different windows   
        . ./scripts/upload $name 1;
        return 5 ;;                                                                 # return 5 means that the function networks_levels is going to run
	2)  ./levels/level2_netzwerk_arp_poisoning/tmux_create_session.sh;
        return 5 ;;
#	2) echo -e "you chose level 2. starting..." ; sudo tmux new-session -s lvl02 -d 'lxc shell lvl02-c02'\; split-window -v -d 'lxc shell lvl02-c01' \; split-window -h -d 'lxc shell lvl02-c03' \; attach ; clear ; ../levels/level2_netzwerk_arp_poisoning/Auswertung.sh ; return 5 ;;
	3) echo -e "\nyou chose level 3" ; return 5 ;;
	4) echo -e "\nyou chose level 4" ; return 5 ;; 
	5) echo -e "\nyou chose level 5" ; return 5 ;;
    b) echo -e "\nyou chose back\n"; return 4 ;;                                    # return 4 means that the function module_menu is going to run
    x) echo -e "\nyou chose exit"; return 0 ;;
    *) echo -e $red"\nWrong option.\n"$clear; return 5;;                            # return 5 means that the function networks_levels is going to run
    esac
}

function netsec_levels ()  
{  
    read_level net-sec                                                              # call read_level function with parameter net-sec
    back_exit                                                                       # call back_exit function        
	echo -ne "Choose a level: "

    read -n 1 menuinput
    case $menuinput in
    1) echo -e "\nyou chose level 1. this is empty.\n" ;  return 6;;
	2) echo -e "\nyou chose level 2. this is empty.\n" ;  return 6;;
	3) echo -e "\nyou chose level 3. this is empty.\n" ;  return 6;;
	4) echo -e "\nyou chose level 4. this is empty.\n" ;  return 6;; 
	5) echo -e "\nyou chose level 5. this is empty.\n" ;  return 6;;
    b) echo -e "\nyou chose back\n"; return 4 ;;                                    # return 4 means that the function module_menu is going to run
    x) echo -e "\nyou chose exit" ; return 0 ;;
    *) echo -e $red"\nWrong option.\n"$clear; return 6;;                            # return 6 means that the function netsec_levels is going to run
    esac
}

function expert_levels()
{
   read_level expert                                                                # call read_level function with parameter expert
    back_exit                                                                       # call back_exit function 
    echo -ne "Choose a level: "

    read -n 1 menuinput
    case $menuinput in
    1) echo -e "\nyou chose level 1. this is empty." ;  return 7;;
	2) echo -e "\nyou chose level 2. this is empty." ;  return 7;;
	3) echo -e "\nyou chose level 3. this is empty." ;  return 7;;
	4) echo -e "\nyou chose level 4. this is empty." ;  return 7;; 
	5) echo -e "\nyou chose level 5. this is empty." ;  return 7;;
    b) echo -e "\nyou chose back\n"; return 2 ;;                                    # return 2 means that the function choose_stage is going to run
    x) echo -e "\nyou chose exit" ; return 0 ;;
    *) echo -e $red"\nWrong option.\n"$clear; return 7;;                            # return 7 means that the function expert_levels is going to run
    esac    
}

function read_level()
{
	i=1
    if [ pupil = $1 ] ; then
        startline=$(( $( grep -n "<pupil>" ./ressources/level_description.txt | sed s/':.*'/''/ ) + 1 ))        # extract line where <TAG> appears
        endline=$(( $( grep -n "</pupil>" ./ressources/level_description.txt | sed s/':.*'/''/ ) - 1 ))         # extract line where <TAG> appears
        print_level                                                                                             # call print_level function to print from start to end line
   elif [ network = $1 ] ; then
        startline=$(( $( grep -n "<network>" ./ressources/level_description.txt | sed s/':.*'/''/ ) + 1 ))      # extract line where <TAG> appears
        endline=$(( $( grep -n "</network>" ./ressources/level_description.txt | sed s/':.*'/''/ ) - 1 ))       # extract line where <TAG> appears
        print_level
    elif [ net-sec = $1 ] ; then
        startline=$(( $( grep -n "<net-sec>" ./ressources/level_description.txt | sed s/':.*'/''/ ) + 1 ))       # extract line where <TAG> appears
        endline=$(( $( grep -n "</net-sec>" ./ressources/level_description.txt | sed s/':.*'/''/ ) - 1 ))        # extract line where <TAG> appears
        print_level
    fi 
}

function print_level
{
    while [ $startline -le $endline ]                                                                           # loop from start Tag to end Tag
            do
                select_line=$(awk 'NR=='$startline'{print}' ./ressources/level_description.txt)                 # save the selected line from selected file in the variable 
                echo -e "$(Colorlight_cyan  $i')') $select_line"                                                # print colored 1) and then the selected line
                i=$(($i+1))                                                                                     # increment due to i) and level i
                startline=$(($startline+1))                                                                     # increment till startline reaches endline
            done

}

function back_exit()
{
	echo -ne "$(ColorRed 'b)ack')  -  Back to previous menu\n"
	echo -ne "$(ColorRed 'e(x)it')\n" 
}

main_menu () 
{
    enter_name
    clear
    welcome="Welcome to hacklab"
    game=\
"This is a game in which you can start learning how to manipulate networks and defend yourself from cyber attacks.
To start, we will need to know how much knowledge you already posess.\nPlease choose one of the following options:\n"
    echo -e "$welcome $(ColorGreen $name)!\n$game"
    returnValue=2

    while : ; do
        case $returnValue in
            1) enter_name;;                                                         # is going to run if a function returns 1
            2) choose_stage;;                                                       # is going to run if a function returns 2
            3) pupil_levels;;                                                       # is going to run if a function returns 3 
            4) module_menu;;                                                        # is going to run if a function returns 4
            5) networks_levels;;                                                    # is going to run if a function returns 5
            6) netsec_levels;;                                                      # is going to run if a function returns 6
            7) expert_levels;;                                                      # is going to run if a function returns 7
            *) return;;
        esac
        returnValue=$?
        [[ $returnValue -ne 0 ]] || break
    done
}

# change working directory into hacklabdir
hacklabdir=$(dirname $(readlink -f "$0"))
cd $hacklabdir

# add relevant paths to environment
PATH=$(echo $PATH:$hacklabdir:$hacklabdir/scripts:$hacklabdir/backend)

#welcome_screen
main_menu
